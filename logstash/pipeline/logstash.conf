input {
	beats {
		port => 5044
	}
}

## Add your filters / logstash plugins configuration here

output {
	elasticsearch {
		hosts => "elasticsearch:9200"
		user => "elastic"
		password => "mobymax"
		index => "logstash-%{+YYYY.MM.dd}"
	}
}

# Apache2 filters

# Apache access log
filter {
	if [type] == "zl-apache" {
	   grok {
	      match => { "message" => ["^%{IPORHOST:[apache2][access][remote_ip]} - %{DATA:[apache2][access][user_name]} \[%{HTTPDATE:[apache2][access][time]}\] \"%{WORD:[apache2][access][method]} %{DATA:[apache2][access][url]} HTTP/%{NUMBER:[apache2][access][http_version]}\" %{NUMBER:[apache2][access][response_code]} (%{NUMBER:[apache2][access][body_sent][bytes]}|-) (%{NUMBER:[apache2][access][body_sent][response_time]}|-)( \"%{DATA:[apache2][access][referrer]}\")?( \"%{DATA:[apache2][access][agent]}\")?",
	        "%{IPORHOST:[apache2][access][remote_ip]} - %{DATA:[apache2][access][user_name]} \\[%{HTTPDATE:[apache2][access][time]}\\] \"-\" %{NUMBER:[apache2][access][response_code]} -" ] }
	      remove_field => "message"
	   }
	   mutate {
	      add_field => { "read_timestamp" => "%{@timestamp}" }
	      copy => {
			 "[apache2][access][url]" => "url"
			"[apache2][access][response_code]" => "response_code"
		}
	   }
	   date {
	      match => [ "[apache2][access][time]", "dd/MMM/YYYY:H:m:s Z" ]
	      remove_field => "[apache2][access][time]"
	   }
	   useragent {
	      source => "[apache2][access][agent]"
	      target => "[apache2][access][user_agent]"
	      remove_field => "[apache2][access][agent]"
	   }
	   geoip {
	      source => "[apache2][access][remote_ip]"
	      target => "[apache2][access][geoip]"
	   }
	}
}
# Apache error log
filter {
    if [type] == "zl-apache-error" {
       grok {
          match => { "message" => ["^\[%{APACHE_TIME:[apache2][error][timestamp]}\] \[%{LOGLEVEL:[apache2][error][level]}\]( \[client %{IPORHOST:[apache2][error][client]}\])? %{GREEDYDATA:[apache2][error][message]}",
            "\[%{APACHE_TIME:[apache2][error][timestamp]}\] \[%{DATA:[apache2][error][module]}:%{LOGLEVEL:[apache2][error][level]}\] \[pid %{NUMBER:[apache2][error][pid]}(:tid %{NUMBER:[apache2][error][tid]})?\]( \[client %{IPORHOST:[apache2][error][client]}\])? %{GREEDYDATA:[apache2][error][message1]}" ] }
          pattern_definitions => {
            "APACHE_TIME" => "%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}"
          }
          remove_field => "message"
       }
       mutate {
          rename => { "[apache2][error][message1]" => "[apache2][error][message]" }
       }
       date {
          match => [ "[apache2][error][timestamp]", "EEE MMM dd H:m:s YYYY", "EEE MMM dd H:m:s.SSSSSS YYYY" ]
          remove_field => "[apache2][error][timestamp]"
       }
    }
}

# CakePHP error parsing
filter {
        if [type] =~ "cake-error*" {
           grok {
              match => { "message" => ["%{DATESTAMP:[cake][error][timestamp]}? %{DATA:[cake][error][level]}?: %{DATA:[cake][error][exception]} %{GREEDYDATA:[cake][error][message]}?\nRequest URL: %{DATA:[cake][error][url]}?\n(?m)%{GREEDYDATA:[cake][error][stack_trace]}"] }
              remove_field => "message"
	      tag_on_failure => ["grok_match_failed"]
           }
	    mutate {
                copy => { "[cake][error][url]" => "url"}
           }
        }
}

# Setting up Nginx web server parsing
filter {
       if [type] =~ "nginx-access*" {
               grok {
                  match => { "message" => ["%{IPORHOST:[nginx][access][remote_ip]} - %{DATA:[nginx][access][user_name]} \[%{HTTPDATE:[nginx][access][time]}\] \"%{WORD:[nginx][access][method]} %{DATA:[nginx][access][url]} HTTP/%{NUMBER:[nginx][access][http_version]}\" %{NUMBER:[nginx][access][response_code]} %{NUMBER:[nginx][access][body_sent][bytes]} \"%{DATA:[nginx][access][referrer]}\" \"%{DATA:[nginx][access][agent]}\""] }
                  remove_field => "message"
               }
               mutate {
                  rename => { "@timestamp" => "read_timestamp" }
		  copy => {
				"[nginx][access][url]" => "url"
		  		"[nginx][access][response_code]" => "response_code"
			}
               }
               date {
                  match => [ "[nginx][access][time]", "dd/MMM/YYYY:H:m:s Z" ]
                  remove_field => "[nginx][access][time]"
               }
               useragent {
                  source => "[nginx][access][agent]"
                  target => "[nginx][access][user_agent]"
                  remove_field => "[nginx][access][agent]"
               }
               geoip {
                  source => "[nginx][access][remote_ip]"
                  target => "[nginx][access][geoip]"
               }
       }
}
# Nginx errors parsing
filter {
        if [type] == "nginx-error*" {
           grok {
              match => { "message" => ["%{DATA:[nginx][error][time]} \[%{DATA:[nginx][error][level]}\] %{NUMBER:[nginx][error][pid]}#%{NUMBER:[nginx][error][tid]}: (\*%{NUMBER:[nginx][error][connection_id]} )?%{GREEDYDATA:[nginx][error][message]}"] }
              remove_field => "message"
           }
           mutate {
              rename => { "@timestamp" => "read_timestamp" }
           }
           date {
              match => [ "[nginx][error][time]", "YYYY/MM/dd H:m:s" ]
              remove_field => "[nginx][error][time]"
           }
        }
}
